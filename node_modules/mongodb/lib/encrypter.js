<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 612faa9106d3f31c019c81e2e601cf7d17c60697
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Encrypter = void 0;
const util_1 = require("util");
const auto_encrypter_1 = require("./client-side-encryption/auto_encrypter");
const constants_1 = require("./constants");
const deps_1 = require("./deps");
const error_1 = require("./error");
const mongo_client_1 = require("./mongo_client");
/** @internal */
const kInternalClient = Symbol('internalClient');
/** @internal */
class Encrypter {
    constructor(client, uri, options) {
        if (typeof options.autoEncryption !== 'object') {
            throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
        }
        // initialize to null, if we call getInternalClient, we may set this it is important to not overwrite those function calls.
        this[kInternalClient] = null;
        this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
        this.needsConnecting = false;
        if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
            options.autoEncryption.keyVaultClient = client;
        }
        else if (options.autoEncryption.keyVaultClient == null) {
            options.autoEncryption.keyVaultClient = this.getInternalClient(client, uri, options);
        }
        if (this.bypassAutoEncryption) {
            options.autoEncryption.metadataClient = undefined;
        }
        else if (options.maxPoolSize === 0) {
            options.autoEncryption.metadataClient = client;
        }
        else {
            options.autoEncryption.metadataClient = this.getInternalClient(client, uri, options);
        }
        if (options.proxyHost) {
            options.autoEncryption.proxyOptions = {
                proxyHost: options.proxyHost,
                proxyPort: options.proxyPort,
                proxyUsername: options.proxyUsername,
                proxyPassword: options.proxyPassword
            };
        }
        this.autoEncrypter = new auto_encrypter_1.AutoEncrypter(client, options.autoEncryption);
    }
    getInternalClient(client, uri, options) {
        // TODO(NODE-4144): Remove new variable for type narrowing
        let internalClient = this[kInternalClient];
        if (internalClient == null) {
            const clonedOptions = {};
            for (const key of [
                ...Object.getOwnPropertyNames(options),
                ...Object.getOwnPropertySymbols(options)
            ]) {
                if (['autoEncryption', 'minPoolSize', 'servers', 'caseTranslate', 'dbName'].includes(key))
                    continue;
                Reflect.set(clonedOptions, key, Reflect.get(options, key));
            }
            clonedOptions.minPoolSize = 0;
            internalClient = new mongo_client_1.MongoClient(uri, clonedOptions);
            this[kInternalClient] = internalClient;
            for (const eventName of constants_1.MONGO_CLIENT_EVENTS) {
                for (const listener of client.listeners(eventName)) {
                    internalClient.on(eventName, listener);
                }
            }
            client.on('newListener', (eventName, listener) => {
                internalClient?.on(eventName, listener);
            });
            this.needsConnecting = true;
        }
        return internalClient;
    }
    async connectInternalClient() {
        // TODO(NODE-4144): Remove new variable for type narrowing
        const internalClient = this[kInternalClient];
        if (this.needsConnecting && internalClient != null) {
            this.needsConnecting = false;
            await internalClient.connect();
        }
    }
    closeCallback(client, force, callback) {
        (0, util_1.callbackify)(this.close.bind(this))(client, force, callback);
    }
    async close(client, force) {
<<<<<<< HEAD
        const maybeError = await this.autoEncrypter.teardown(!!force).catch(e => e);
        const internalClient = this[kInternalClient];
        if (internalClient != null && client !== internalClient) {
            return internalClient.close(force);
        }
        if (maybeError) {
            throw maybeError;
=======
        let error;
        try {
            await this.autoEncrypter.teardown(force);
        }
        catch (autoEncrypterError) {
            error = autoEncrypterError;
        }
        const internalClient = this[kInternalClient];
        if (internalClient != null && client !== internalClient) {
            return await internalClient.close(force);
        }
        if (error != null) {
            throw error;
>>>>>>> 612faa9106d3f31c019c81e2e601cf7d17c60697
        }
    }
    static checkForMongoCrypt() {
        const mongodbClientEncryption = (0, deps_1.getMongoDBClientEncryption)();
        if ('kModuleError' in mongodbClientEncryption) {
            throw new error_1.MongoMissingDependencyError('Auto-encryption requested, but the module is not installed. ' +
<<<<<<< HEAD
                'Please add `mongodb-client-encryption` as a dependency of your project');
=======
                'Please add `mongodb-client-encryption` as a dependency of your project', {
                cause: mongodbClientEncryption['kModuleError'],
                dependencyName: 'mongodb-client-encryption'
            });
>>>>>>> 612faa9106d3f31c019c81e2e601cf7d17c60697
        }
    }
}
exports.Encrypter = Encrypter;
<<<<<<< HEAD
//# sourceMappingURL=encrypter.js.map
=======
'use strict';
const MongoClient = require('./mongo_client');
const BSON = require('./core/connection/utils').retrieveBSON();
const MongoError = require('./core/error').MongoError;

let mongodbClientEncryption = undefined;
try {
  // Ensure you always wrap an optional require in the try block NODE-3199
  mongodbClientEncryption = require('mongodb-client-encryption');
} catch (err) {
  throw new MongoError(
    'Auto-encryption requested, but the module is not installed. ' +
      'Please add `mongodb-client-encryption` as a dependency of your project'
  );
}

if (
  mongodbClientEncryption === undefined ||
  typeof mongodbClientEncryption.extension !== 'function'
) {
  throw new MongoError(
    'loaded version of `mongodb-client-encryption` does not have property `extension`. ' +
      'Please make sure you are loading the correct version of `mongodb-client-encryption`'
  );
}

const AutoEncrypter = mongodbClientEncryption.extension(require('../index')).AutoEncrypter;

const kInternalClient = Symbol('internalClient');

class Encrypter {
  /**
   * @param {MongoClient} client
   * @param {{autoEncryption: import('./mongo_client').AutoEncryptionOptions, bson: object}} options
   */
  constructor(client, options) {
    this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
    this.needsConnecting = false;

    if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
      options.autoEncryption.keyVaultClient = client;
    } else if (options.autoEncryption.keyVaultClient == null) {
      options.autoEncryption.keyVaultClient = this.getInternalClient(client);
    }

    if (this.bypassAutoEncryption) {
      options.autoEncryption.metadataClient = undefined;
    } else if (options.maxPoolSize === 0) {
      options.autoEncryption.metadataClient = client;
    } else {
      options.autoEncryption.metadataClient = this.getInternalClient(client);
    }

    options.autoEncryption.bson = Encrypter.makeBSON(options);

    this.autoEncrypter = new AutoEncrypter(client, options.autoEncryption);
  }

  getInternalClient(client) {
    if (!this[kInternalClient]) {
      const clonedOptions = {};

      for (const key of Object.keys(client.s.options)) {
        if (
          ['autoEncryption', 'minPoolSize', 'servers', 'caseTranslate', 'dbName'].indexOf(key) !==
          -1
        )
          continue;
        clonedOptions[key] = client.s.options[key];
      }

      clonedOptions.minPoolSize = 0;

      const allEvents = [
        // APM
        'commandStarted',
        'commandSucceeded',
        'commandFailed',

        // SDAM
        'serverOpening',
        'serverClosed',
        'serverDescriptionChanged',
        'serverHeartbeatStarted',
        'serverHeartbeatSucceeded',
        'serverHeartbeatFailed',
        'topologyOpening',
        'topologyClosed',
        'topologyDescriptionChanged',

        // Legacy
        'joined',
        'left',
        'ping',
        'ha',

        // CMAP
        'connectionPoolCreated',
        'connectionPoolClosed',
        'connectionCreated',
        'connectionReady',
        'connectionClosed',
        'connectionCheckOutStarted',
        'connectionCheckOutFailed',
        'connectionCheckedOut',
        'connectionCheckedIn',
        'connectionPoolCleared'
      ];

      this[kInternalClient] = new MongoClient(client.s.url, clonedOptions);

      for (const eventName of allEvents) {
        for (const listener of client.listeners(eventName)) {
          this[kInternalClient].on(eventName, listener);
        }
      }

      client.on('newListener', (eventName, listener) => {
        this[kInternalClient].on(eventName, listener);
      });

      this.needsConnecting = true;
    }
    return this[kInternalClient];
  }

  connectInternalClient(callback) {
    if (this.needsConnecting) {
      this.needsConnecting = false;
      return this[kInternalClient].connect(callback);
    }

    return callback();
  }

  close(client, force, callback) {
    this.autoEncrypter.teardown(e => {
      if (this[kInternalClient] && client !== this[kInternalClient]) {
        return this[kInternalClient].close(force, callback);
      }
      callback(e);
    });
  }

  static makeBSON(options) {
    return (
      (options || {}).bson ||
      new BSON([
        BSON.Binary,
        BSON.Code,
        BSON.DBRef,
        BSON.Decimal128,
        BSON.Double,
        BSON.Int32,
        BSON.Long,
        BSON.Map,
        BSON.MaxKey,
        BSON.MinKey,
        BSON.ObjectId,
        BSON.BSONRegExp,
        BSON.Symbol,
        BSON.Timestamp
      ])
    );
  }
}

module.exports = { Encrypter };
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
=======
//# sourceMappingURL=encrypter.js.map
>>>>>>> 612faa9106d3f31c019c81e2e601cf7d17c60697
