<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 612faa9106d3f31c019c81e2e601cf7d17c60697
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandOperation = void 0;
const error_1 = require("../error");
const explain_1 = require("../explain");
const read_concern_1 = require("../read_concern");
const server_selection_1 = require("../sdam/server_selection");
const utils_1 = require("../utils");
const write_concern_1 = require("../write_concern");
const operation_1 = require("./operation");
/** @internal */
class CommandOperation extends operation_1.AbstractOperation {
    constructor(parent, options) {
        super(options);
        this.options = options ?? {};
        // NOTE: this was explicitly added for the add/remove user operations, it's likely
        //       something we'd want to reconsider. Perhaps those commands can use `Admin`
        //       as a parent?
        const dbNameOverride = options?.dbName || options?.authdb;
        if (dbNameOverride) {
            this.ns = new utils_1.MongoDBNamespace(dbNameOverride, '$cmd');
        }
        else {
            this.ns = parent
                ? parent.s.namespace.withCollection('$cmd')
                : new utils_1.MongoDBNamespace('admin', '$cmd');
        }
        this.readConcern = read_concern_1.ReadConcern.fromOptions(options);
        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options);
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
            this.explain = explain_1.Explain.fromOptions(options);
        }
        else if (options?.explain != null) {
            throw new error_1.MongoInvalidArgumentError(`Option "explain" is not supported on this command`);
        }
    }
    get canRetryWrite() {
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
            return this.explain == null;
        }
        return true;
    }
<<<<<<< HEAD
    async executeCommand(server, session, cmd) {
        // TODO: consider making this a non-enumerable property
=======
    async executeCommand(server, session, cmd, responseType) {
>>>>>>> 612faa9106d3f31c019c81e2e601cf7d17c60697
        this.server = server;
        const options = {
            ...this.options,
            ...this.bsonOptions,
            readPreference: this.readPreference,
            session
        };
        const serverWireVersion = (0, utils_1.maxWireVersion)(server);
        const inTransaction = this.session && this.session.inTransaction();
        if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
            Object.assign(cmd, { readConcern: this.readConcern });
        }
        if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
            options.omitReadPreference = true;
        }
        if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
            write_concern_1.WriteConcern.apply(cmd, this.writeConcern);
        }
        if (options.collation &&
            typeof options.collation === 'object' &&
            !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
            Object.assign(cmd, { collation: options.collation });
        }
        if (typeof options.maxTimeMS === 'number') {
            cmd.maxTimeMS = options.maxTimeMS;
        }
        if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
            cmd = (0, utils_1.decorateWithExplain)(cmd, this.explain);
        }
<<<<<<< HEAD
        return server.commandAsync(this.ns, cmd, options);
    }
}
exports.CommandOperation = CommandOperation;
//# sourceMappingURL=command.js.map
=======
'use strict';

const Aspect = require('./operation').Aspect;
const OperationBase = require('./operation').OperationBase;
const applyWriteConcern = require('../utils').applyWriteConcern;
const debugOptions = require('../utils').debugOptions;
const handleCallback = require('../utils').handleCallback;
const MongoError = require('../core').MongoError;
const ReadPreference = require('../core').ReadPreference;
const MongoDBNamespace = require('../utils').MongoDBNamespace;
const extractCommand = require('../command_utils').extractCommand;

const debugFields = [
  'authSource',
  'w',
  'wtimeout',
  'j',
  'native_parser',
  'forceServerObjectId',
  'serializeFunctions',
  'raw',
  'promoteLongs',
  'promoteValues',
  'promoteBuffers',
  'bsonRegExp',
  'bufferMaxEntries',
  'numberOfRetries',
  'retryMiliSeconds',
  'readPreference',
  'pkFactory',
  'parentDb',
  'promiseLibrary',
  'noListener'
];

class CommandOperation extends OperationBase {
  constructor(db, options, collection, command) {
    super(options);

    if (!this.hasAspect(Aspect.WRITE_OPERATION)) {
      if (collection != null) {
        this.options.readPreference = ReadPreference.resolve(collection, options);
      } else {
        this.options.readPreference = ReadPreference.resolve(db, options);
      }
    } else {
      if (collection != null) {
        applyWriteConcern(this.options, { db, coll: collection }, this.options);
      } else {
        applyWriteConcern(this.options, { db }, this.options);
      }
      this.options.readPreference = ReadPreference.primary;
    }

    this.db = db;

    if (command != null) {
      this.command = command;
    }

    if (collection != null) {
      this.collection = collection;
    }
  }

  _buildCommand() {
    if (this.command != null) {
      return this.command;
    }
  }

  execute(callback) {
    const db = this.db;
    const options = Object.assign({}, this.options);

    // Did the user destroy the topology
    if (db.serverConfig && db.serverConfig.isDestroyed()) {
      return callback(new MongoError('topology was destroyed'));
    }

    let command;
    try {
      command = this._buildCommand();
    } catch (e) {
      return callback(e);
    }

    // Get the db name we are executing against
    const dbName = options.dbName || options.authdb || db.databaseName;

    // Convert the readPreference if its not a write
    if (this.hasAspect(Aspect.WRITE_OPERATION)) {
      if (options.writeConcern && (!options.session || !options.session.inTransaction())) {
        command.writeConcern = options.writeConcern;
      }
    }

    // Debug information
    if (db.s.logger.isDebug()) {
      const extractedCommand = extractCommand(command);
      db.s.logger.debug(
        `executing command ${JSON.stringify(
          extractedCommand.shouldRedact ? `${extractedCommand.name} details REDACTED` : command
        )} against ${dbName}.$cmd with options [${JSON.stringify(
          debugOptions(debugFields, options)
        )}]`
      );
    }

    const namespace =
      this.namespace != null ? this.namespace : new MongoDBNamespace(dbName, '$cmd');

    // Execute command
    db.s.topology.command(namespace, command, options, (err, result) => {
      if (err) return handleCallback(callback, err);
      if (options.full) return handleCallback(callback, null, result);
      handleCallback(callback, null, result.result);
    });
  }
}

module.exports = CommandOperation;
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
=======
        return await server.command(this.ns, cmd, options, responseType);
    }
}
exports.CommandOperation = CommandOperation;
//# sourceMappingURL=command.js.map
>>>>>>> 612faa9106d3f31c019c81e2e601cf7d17c60697
