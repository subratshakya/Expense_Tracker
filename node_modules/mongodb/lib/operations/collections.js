<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> 612faa9106d3f31c019c81e2e601cf7d17c60697
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionsOperation = void 0;
const collection_1 = require("../collection");
const operation_1 = require("./operation");
/** @internal */
class CollectionsOperation extends operation_1.AbstractOperation {
    constructor(db, options) {
        super(options);
        this.options = options;
        this.db = db;
    }
<<<<<<< HEAD
=======
    get commandName() {
        return 'listCollections';
    }
>>>>>>> 612faa9106d3f31c019c81e2e601cf7d17c60697
    async execute(server, session) {
        // Let's get the collection names
        const documents = await this.db
            .listCollections({}, { ...this.options, nameOnly: true, readPreference: this.readPreference, session })
            .toArray();
        const collections = [];
        for (const { name } of documents) {
            if (!name.includes('$')) {
                // Filter collections removing any illegal ones
                collections.push(new collection_1.Collection(this.db, name, this.db.s.options));
            }
        }
        // Return the collection objects
        return collections;
    }
}
exports.CollectionsOperation = CollectionsOperation;
<<<<<<< HEAD
//# sourceMappingURL=collections.js.map
=======
'use strict';

const OperationBase = require('./operation').OperationBase;
const handleCallback = require('../utils').handleCallback;

let collection;
function loadCollection() {
  if (!collection) {
    collection = require('../collection');
  }
  return collection;
}

class CollectionsOperation extends OperationBase {
  constructor(db, options) {
    super(options);

    this.db = db;
  }

  execute(callback) {
    const db = this.db;
    let options = this.options;

    let Collection = loadCollection();

    options = Object.assign({}, options, { nameOnly: true });
    // Let's get the collection names
    db.listCollections({}, options).toArray((err, documents) => {
      if (err != null) return handleCallback(callback, err, null);
      // Filter collections removing any illegal ones
      documents = documents.filter(doc => {
        return doc.name.indexOf('$') === -1;
      });

      // Return the collection objects
      handleCallback(
        callback,
        null,
        documents.map(d => {
          return new Collection(
            db,
            db.s.topology,
            db.databaseName,
            d.name,
            db.s.pkFactory,
            db.s.options
          );
        })
      );
    });
  }
}

module.exports = CollectionsOperation;
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
=======
//# sourceMappingURL=collections.js.map
>>>>>>> 612faa9106d3f31c019c81e2e601cf7d17c60697
