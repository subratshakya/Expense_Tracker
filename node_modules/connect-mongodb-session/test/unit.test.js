<<<<<<< HEAD
'use strict';

const assert = require('assert');
const connectMongoDBSession = require('../');
const ee = require('events').EventEmitter;
const mongodb = require('mongodb');
const sinon = require('sinon');

describe('connectMongoDBSession', function() {
  var StoreStub;

  afterEach(() => sinon.restore());

  beforeEach(function() {
=======
var assert = require('assert');
var connectMongoDBSession = require('../');
var ee = require('events').EventEmitter;
var mongodb = require('mongodb');
var strawman = require('strawman');

describe('connectMongoDBSession', function() {
  var client = {"db": {}};
  var db;
  var StoreStub;

  beforeEach(function() {
    db = strawman({
      collection: { argumentNames: ['collection'], chain: true },
      createIndex: { argumentNames: ['index', 'options', 'callback'] },
      findOne: { argumentNames: ['query', 'callback'] },
      deleteOne: { argumentNames: ['query', 'callback'] },
      deleteMany: { argumentNames: ['query', 'callback'] },
      updateOne: { argumentNames: ['query', 'update', 'options', 'callback' ] }
    });

    client.db = function(n) {return db;};

    mongodb.MongoClient.connect = function(uri, options, callback) {
      process.nextTick(function() { callback(null, client); });
    };

>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
    StoreStub = function() {};
    StoreStub.prototype = { connectMongoDB: 1 };
  });

  describe('options', function() {
    it('can specify uri', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });
<<<<<<< HEAD
      var session = new SessionStore({ uri: 'mongodb://host:1111/db' });
      assert.equal(session.options.uri, 'mongodb://host:1111/db');
=======
      var session = new SessionStore({ uri: 'mongodb://host:port/db' });
      assert.equal(session.options.uri, 'mongodb://host:port/db');
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      assert.equal(session.options.idField, '_id');
      done();
    });

    it('can specify collection', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });
      var session = SessionStore({ collection: 'notSessions' });
<<<<<<< HEAD
      assert.equal(session.options.uri, 'mongodb://127.0.0.1:27017/test');
=======
      assert.equal(session.options.uri, 'mongodb://localhost:27017/test');
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      assert.equal(session.options.collection, 'notSessions');
      done();
    });

    it('can specify expires', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });
      var session = new SessionStore({ expires: 25 });
<<<<<<< HEAD
      assert.equal(session.options.uri, 'mongodb://127.0.0.1:27017/test');
=======
      assert.equal(session.options.uri, 'mongodb://localhost:27017/test');
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      assert.equal(session.options.expires, 25);
      done();
    });

    it('can specify idField', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });
      var session = new SessionStore({ idField: 'sessionId' });
<<<<<<< HEAD
      assert.equal(session.options.uri, 'mongodb://127.0.0.1:27017/test');
=======
      assert.equal(session.options.uri, 'mongodb://localhost:27017/test');
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      assert.deepEqual(session._generateQuery('1234'), { sessionId: '1234' });
      done();
    });

    it('can specify databaseName', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });
      var session = new SessionStore({ databaseName: 'other_db' });
      assert.equal(session.options.databaseName, 'other_db');
      done();
    });
  });

  it('can get Store object from Express 3', function(done) {
    var SessionStore = connectMongoDBSession({ session: { Store: StoreStub } });
    assert.ok(SessionStore.prototype.connectMongoDB);
    done();
  });

  it('specifying options is optional', function(done) {
    var SessionStore = connectMongoDBSession({ Store: StoreStub });
<<<<<<< HEAD
=======
    var numIndexCalls = 0;
    db.createIndex.on('called', function(args) {
      assert.equal(++numIndexCalls, 1);
      assert.equal(args.index.expires, 1);
      args.callback();
    });
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070

    var session = new SessionStore(function(error) {
      assert.ifError(error);
      done();
    });
<<<<<<< HEAD
    assert.equal(session.options.uri, 'mongodb://127.0.0.1:27017/test');
=======
    assert.equal(session.options.uri, 'mongodb://localhost:27017/test');
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
  });

  it('uses default options and no callback if no args passed', function(done) {
    var SessionStore = connectMongoDBSession({ Store: StoreStub });
<<<<<<< HEAD

    var session = new SessionStore();
    assert.equal(session.options.uri, 'mongodb://127.0.0.1:27017/test');
=======
    var numIndexCalls = 0;
    db.createIndex.on('called', function(args) {
      assert.equal(++numIndexCalls, 1);
      assert.equal(args.index.expires, 1);
      args.callback();
    });

    var session = new SessionStore();
    assert.equal(session.options.uri, 'mongodb://localhost:27017/test');
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070

    session.on('connected', function() {
      done();
    });
  });

  it('throws an error when connection fails and no callback', function(done) {
<<<<<<< HEAD
    sinon.stub(mongodb.MongoClient.prototype, 'connect').callsFake(() => {
      return Promise.reject(new Error('Cant connect'));
    });
=======
    mongodb.MongoClient.connect = function(uri, options, callback) {
      // purposely make callback sync
      callback(new Error('Cant connect'));
    };
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070

    var SessionStore = connectMongoDBSession({ Store: StoreStub });

    var threw = false;
    try {
      new SessionStore();
    } catch (error) {
      threw = true;
      assert.equal(error.message, 'Error connecting to db: Cant connect');
    }

    done();
  });

  it('passes error to callback if specified', function(done) {
<<<<<<< HEAD
    sinon.stub(mongodb.MongoClient.prototype, 'connect').callsFake(() => {
      return Promise.reject(new Error('connect issues'));
    });
=======
    mongodb.MongoClient.connect = function(uri, options, callback) {
      process.nextTick(function() { callback(new Error('Cant connect')); });
    };
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070

    var SessionStore = connectMongoDBSession({ Store: StoreStub });
    var numSources = 2;
    var store = new SessionStore(function(error) {
      assert.ok(error);
      --numSources || done();
    });
    store.once('error', function(error) {
      assert.ok(error);
      --numSources || done();
    });
  });

  it('handles index errors', function(done) {
    var SessionStore = connectMongoDBSession({ Store: StoreStub });
<<<<<<< HEAD

    sinon.stub(mongodb.Collection.prototype, 'createIndex').callsFake(() => {
      return Promise.reject(new Error('Index fail'));
=======
    var numIndexCalls = 0;
    db.createIndex.on('called', function(args) {
      assert.equal(++numIndexCalls, 1);
      assert.equal(args.index.expires, 1);
      args.callback(new Error('Index fail'));
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
    });

    var session = new SessionStore(function(error) {
      assert.equal(error.message, 'Error creating index: Index fail');
      done();
    });
  });

  describe('get()', function() {
<<<<<<< HEAD
    it('gets the session', function(done) {
      const SessionStore = connectMongoDBSession({ Store: StoreStub });

      var session = new SessionStore();

      sinon.stub(session.collection, 'findOne').callsFake(() => {
        return Promise.resolve({ expires: new Date('2040-06-01T00:00:00.000Z'), session: { data: 1 } });
      });
      session.get('1234', function(error, session) {
        assert.ifError(error);
        assert.deepStrictEqual(session, { data: 1 });
        done();
      });
    });

    it('handles get() errors', function(done) {
      const SessionStore = connectMongoDBSession({ Store: StoreStub });

      const session = new SessionStore();
      sinon.stub(session.collection, 'findOne').callsFake(() => {
        return Promise.reject(new Error('fail!'));
=======
    var numIndexCalls;

    beforeEach(function() {
      numIndexCalls = 0;

      db.createIndex.on('called', function(args) {
        assert.equal(++numIndexCalls, 1);
        assert.equal(args.index.expires, 1);
        args.callback();
      });
    });

    it('buffers get() calls', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });
      var emitter = new ee();

      mongodb.MongoClient.connect = function(uri, options, callback) {
        emitter.on('success', function() {
          callback(null, client);
        });
      };

      var session = new SessionStore();

      db.findOne.on('called', function(args) {
        args.callback(null,
          { expires: new Date('2040-06-01T00:00:00.000Z'), session: { data: 1 } });
      });
      session.get('1234', function(error) {
        assert.ifError(error);
        assert.equal(numIndexCalls, 1);
        done();
      });

      setImmediate(function() {
        emitter.emit('success');
      });
    });

    it('handles get() errors', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });

      var session = new SessionStore();
      db.findOne.on('called', function(args) {
        args.callback(new Error('fail!'));
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      });

      session.get('1234', function(error) {
        assert.ok(error);
        assert.equal(error.message, 'Error finding 1234: fail!');
        done();
      });
    });

    it('calls destroy() on stale sessions', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });
<<<<<<< HEAD

      var session = new SessionStore();
      sinon.stub(session.collection, 'findOne').callsFake(() => {
        return Promise.resolve({ expires: new Date('2011-06-01T00:00:00.000Z') });
      });
      sinon.stub(session.collection, 'deleteOne').callsFake(() => {
        return Promise.resolve();
=======
      var numRemoveCalls = 0;

      var session = new SessionStore();
      db.findOne.on('called', function(args) {
        args.callback(null, { expires: new Date('2011-06-01T00:00:00.000Z') });
      });

      db.deleteOne.on('called', function(args) {
        ++numRemoveCalls;
        assert.equal(args.query._id, '1234');
        args.callback();
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      });

      session.get('1234', function(error, doc) {
        assert.ifError(error);
        assert.ok(!doc);
<<<<<<< HEAD
        assert.equal(session.collection.deleteOne.getCalls().length, 1);
=======
        assert.equal(numRemoveCalls, 1);
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
        done();
      });
    });

    it('returns empty if no session found', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });

      var session = new SessionStore();
<<<<<<< HEAD
      sinon.stub(session.collection, 'findOne').callsFake(() => {
        return Promise.resolve(null);
=======
      db.findOne.on('called', function(args) {
        args.callback(null, null);
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      });

      session.get('1234', function(error, doc) {
        assert.ifError(error);
        assert.ok(!doc);
        done();
      });
    });
  });

  describe('destroy()', function() {
<<<<<<< HEAD
=======
    var numIndexCalls;

    beforeEach(function() {
      numIndexCalls = 0;

      db.createIndex.on('called', function(args) {
        assert.equal(++numIndexCalls, 1);
        assert.equal(args.index.expires, 1);
        args.callback();
      });
    });

    it('buffers until connected', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });
      var emitter = new ee();

      mongodb.MongoClient.connect = function(uri, options, callback) {
        emitter.on('success', function() {
          callback(null, client);
        });
      };

      var session = new SessionStore();

      db.deleteOne.on('called', function(args) {
        args.callback(null);
      });
      session.destroy('1234', function(error) {
        assert.ifError(error);
        assert.equal(numIndexCalls, 1);
        done();
      });

      setImmediate(function() {
        emitter.emit('success');
      });
    });

>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
    it('reports driver errors', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });

      var session = new SessionStore();
<<<<<<< HEAD
      sinon.stub(session.collection, 'deleteOne')
        .callsFake(() => Promise.reject(new Error('roadrunners pachyderma')));

      session.destroy('1234', function(error) {
        assert.ok(error);
        assert.equal(error.message, 'Error destroying 1234: roadrunners pachyderma');
=======
      db.deleteOne.on('called', function(args) {
        args.callback(new Error('fail!'));
      });

      session.destroy('1234', function(error) {
        assert.ok(error);
        assert.equal(error.message, 'Error destroying 1234: fail!');
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
        done();
      });
    });
  });

<<<<<<< HEAD
  describe('set()', function() {
=======
  describe('set()', function(done) {
    var numIndexCalls;

    beforeEach(function() {
      numIndexCalls = 0;

      db.createIndex.on('called', function(args) {
        assert.equal(++numIndexCalls, 1);
        assert.equal(args.index.expires, 1);
        args.callback();
      });
    });

    it('buffers until connected', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });
      var emitter = new ee();

      mongodb.MongoClient.connect = function(uri, options, callback) {
        emitter.on('success', function() {
          callback(null, client);
        });
      };

      var session = new SessionStore();

      db.updateOne.on('called', function(args) {
        args.callback(null);
      });
      session.set('1234', { test: 1 }, function(error) {
        assert.ifError(error);
        assert.equal(numIndexCalls, 1);
        done();
      });

      setImmediate(function() {
        emitter.emit('success');
      });
    });

>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
    it('converts expires to a date', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });

      var session = new SessionStore();

<<<<<<< HEAD
      sinon.stub(session.collection, 'updateOne').callsFake(() => {
        return Promise.resolve(null);
=======
      db.updateOne.on('called', function(args) {
        assert.ok(args.update.$set.expires instanceof Date);
        assert.equal(args.update.$set.expires.getTime(),
          new Date('2011-06-01T00:00:00.000Z').getTime());
        args.callback(null);
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      });
      var update = {
        test: 1,
        cookie: { expires: '2011-06-01T00:00:00.000Z' }
      };
      session.set('1234', update, function(error) {
        assert.ifError(error);
<<<<<<< HEAD
        assert.equal(session.collection.updateOne.getCalls().length, 1);
        assert.ok(session.collection.updateOne.getCalls()[0].args[1].$set.expires instanceof Date);
        assert.equal(session.collection.updateOne.getCalls()[0].args[1].$set.expires.getTime(),
          new Date('2011-06-01T00:00:00.000Z').getTime());
=======
        assert.equal(db.updateOne.calls.length, 1);
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
        done();
      });
    });

    it('handles set() errors', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });

      var session = new SessionStore();
<<<<<<< HEAD
      sinon.stub(session.collection, 'updateOne').callsFake(() => {
        return Promise.reject(new Error('taco tuesday'));
=======
      db.updateOne.on('called', function(args) {
        args.callback(new Error('fail!'));
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      });

      session.set('1234', {}, function(error) {
        assert.ok(error);
<<<<<<< HEAD
        assert.equal(error.message, 'Error setting 1234 to {}: taco tuesday');
=======
        assert.equal(error.message, 'Error setting 1234 to {}: fail!');
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
        done();
      });
    });

    /** For backwards compatibility with connect-mongo */
    it('converts cookies to JSON strings', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });

      var session = new SessionStore();

<<<<<<< HEAD
      sinon.stub(session.collection, 'updateOne').callsFake(() => {
        return Promise.resolve(null);
=======
      db.updateOne.on('called', function(args) {
        assert.equal(args.update.$set.session.cookie, 'put that cookie down!');
        args.callback(null);
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      });
      var update = {
        test: 1,
        cookie: { toJSON: function() { return 'put that cookie down!'; } }
      };
      session.set('1234', update, function(error) {
        assert.ifError(error);
<<<<<<< HEAD
        assert.equal(session.collection.updateOne.getCalls().length, 1);
        assert.equal(
          session.collection.updateOne.getCalls()[0].args[1].$set.session.cookie,
          'put that cookie down!'
        );
=======
        assert.equal(db.updateOne.calls.length, 1);
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
        done();
      });
    });

    /** For backwards compatibility with connect-mongo */
    it('unless they do not have a toJSON()', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });

      var session = new SessionStore();

<<<<<<< HEAD
      sinon.stub(session.collection, 'updateOne').callsFake(() => {
        return Promise.resolve(null);
=======
      db.updateOne.on('called', function(args) {
        assert.deepEqual(args.update.$set.session.cookie, { test: 2 });
        args.callback(null);
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
      });
      var update = {
        test: 1,
        cookie: { test: 2 }
      };
      session.set('1234', update, function(error) {
        assert.ifError(error);
<<<<<<< HEAD
        assert.equal(session.collection.updateOne.getCalls().length, 1);
        assert.deepEqual(
          session.collection.updateOne.getCalls()[0].args[1].$set.session.cookie,
          { test: 2 }
        );
=======
        assert.equal(db.updateOne.calls.length, 1);
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
        done();
      });
    });
  });

<<<<<<< HEAD
  describe('clear()', function() {
=======
  describe('clear()', function(done){
    var numIndexCalls;

    beforeEach(function() {
      numIndexCalls = 0;

      db.createIndex.on('called', function(args) {
        assert.equal(++numIndexCalls, 1);
        assert.equal(args.index.expires, 1);
        args.callback();
      });
    });

>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
    it('clears the session store', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });

      var session = new SessionStore();
<<<<<<< HEAD
      sinon.stub(session.collection, 'deleteMany').callsFake(() => Promise.resolve());

      session.clear(function(error) {
        assert.ifError(error);
        assert.ok(session.collection.deleteMany.calledOnce);
        assert.deepStrictEqual(session.collection.deleteMany.getCalls()[0].args[0], {});
=======
      db.deleteMany.on('called', function(args) {
        args.callback(null);
      });

      session.clear(function(error) {
        assert.ifError(error);
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
        done();
      });
    });

    it('handles set() errors', function(done) {
      var SessionStore = connectMongoDBSession({ Store: StoreStub });

      var session = new SessionStore();
<<<<<<< HEAD
      sinon.stub(session.collection, 'deleteMany').
        callsFake(() => Promise.reject(new Error('clear issue')));

      session.clear(function(error) {
        assert.ok(error);
        assert.equal(error.message, 'Error clearing all sessions: clear issue');
=======
      db.deleteMany.on('called', function(args) {
        args.callback(new Error('fail!'));
      });

      session.clear(function(error) {
        assert.ok(error);
        assert.equal(error.message, 'Error clearing all sessions: fail!');
>>>>>>> d9b5d8d4d7e7782577668ed9860ec566a14c8070
        done();
      });
    });
  });
});
